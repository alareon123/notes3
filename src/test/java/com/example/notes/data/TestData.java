package com.example.notes.data;

import com.example.notes.models.NoteCreateRequest;
import com.example.notes.models.NoteUpdateRequest;

/**
 * Класс TestData - хранилище тестовых данных для всех тестов приложения.
 *
 * ЗАЧЕМ НУЖЕН ЭТОТ КЛАСС:
 * =====================
 * Представьте, что у вас 50 тестов, и в каждом нужно создать заметку с заголовком "Test Note".
 * Можно в каждом тесте писать:
 *     new NoteCreateRequest("Test Note Title", "Description", "Home")
 *
 * Но это плохо, потому что:
 * 1. Код дублируется 50 раз
 * 2. Если надо изменить тестовые данные - придётся менять во всех 50 местах
 * 3. Легко допустить опечатку или несоответствие между тестами
 *
 * РЕШЕНИЕ - создать один класс с готовыми тестовыми данными:
 *     TestData.simpleNote()
 * Теперь все тесты используют ОДИН источник данных. Изменили в одном месте - поменялось везде.
 *
 * ПАТТЕРН "TEST DATA BUILDER":
 * ===========================
 * Это популярный паттерн в тестировании - создавать специальные методы,
 * которые возвращают готовые объекты для тестов. Это делает тесты:
 * - Короче (меньше кода)
 * - Понятнее (метод simpleNote() говорит сам за себя)
 * - Надёжнее (данные проверены и работают)
 *
 * ПОЧЕМУ МЕТОДЫ СТАТИЧЕСКИЕ (static):
 * ===================================
 * Ключевое слово "static" означает, что метод принадлежит классу, а не объекту.
 * Это позволяет вызывать методы БЕЗ создания экземпляра класса:
 *
 * Без static (неудобно):
 *     TestData testData = new TestData();  // Создаём объект
 *     NoteCreateRequest note = testData.simpleNote();  // Вызываем метод
 *
 * Со static (удобно):
 *     NoteCreateRequest note = TestData.simpleNote();  // Сразу вызываем метод
 *
 * Для утилитарных классов (которые просто предоставляют методы-помощники)
 * static методы - стандартная практика в Java.
 */
public class TestData {

    /**
     * Создаёт простую валидную заметку для базовых тестов.
     *
     * ЧТО ВОЗВРАЩАЕТ:
     * Объект NoteCreateRequest с типичными данными:
     * - Заголовок: "Test Note Title"
     * - Описание: "This is a test note description"
     * - Категория: "Home"
     *
     * КОГДА ИСПОЛЬЗОВАТЬ:
     * В тестах, где нужна просто работающая заметка без особых требований.
     * Например:
     * - Тест создания заметки
     * - Тест получения списка заметок
     * - Тест поиска заметок
     *
     * ПРИМЕР ИСПОЛЬЗОВАНИЯ В ТЕСТЕ:
     * <pre>
     * {@code
     * @Test
     * void shouldCreateNote() {
     *     NoteCreateRequest request = TestData.simpleNote();
     *     // Используем request в тесте...
     * }
     * }
     * </pre>
     *
     * @return объект NoteCreateRequest с заполненными валидными данными
     */
    public static NoteCreateRequest simpleNote() {
        return new NoteCreateRequest(
                "Test Note Title",                      // Заголовок заметки
                "This is a test note description",      // Описание заметки
                "Home"                                   // Категория заметки
        );
    }

    /**
     * Создаёт заметку с пустым заголовком для тестирования валидации.
     *
     * ЧТО ВОЗВРАЩАЕТ:
     * Объект NoteCreateRequest с пустым заголовком (""), но валидным описанием и категорией.
     *
     * ЗАЧЕМ НУЖНО:
     * Для негативных тестов - проверки того, что система правильно обрабатывает
     * некорректные данные. В данном случае проверяем:
     * - Отклоняет ли API заметку без заголовка?
     * - Показывает ли понятное сообщение об ошибке?
     *
     * КОНЦЕПЦИЯ НЕГАТИВНОГО ТЕСТИРОВАНИЯ:
     * Тестируем не только "happy path" (когда всё хорошо), но и случаи ошибок.
     * Это важно, потому что пользователи часто вводят некорректные данные:
     * - По ошибке (забыли заполнить поле)
     * - По незнанию (не поняли требования)
     * - Специально (пытаются взломать систему)
     *
     * ПРИМЕР ИСПОЛЬЗОВАНИЯ:
     * <pre>
     * {@code
     * @Test
     * void shouldRejectNoteWithEmptyTitle() {
     *     NoteCreateRequest request = TestData.noteWithEmptyTitle();
     *     // Ожидаем, что API вернёт ошибку 400 Bad Request
     * }
     * }
     * </pre>
     *
     * @return объект NoteCreateRequest с пустым заголовком для тестирования валидации
     */
    public static NoteCreateRequest noteWithEmptyTitle() {
        return new NoteCreateRequest(
                "",                          // Пустой заголовок - невалидные данные
                "Note with empty title",     // Описание есть
                "Work"                       // Категория есть
        );
    }

    /**
     * Создаёт заметку с пустым описанием для тестирования валидации.
     *
     * ЧТО ВОЗВРАЩАЕТ:
     * Объект NoteCreateRequest с валидным заголовком и категорией, но пустым описанием.
     *
     * ЗАЧЕМ НУЖНО:
     * Ещё один негативный тест - проверяем, как система реагирует на отсутствие описания.
     * Возможно, описание - необязательное поле, тогда этот тест должен пройти успешно.
     * Или описание обязательно - тогда должна быть ошибка валидации.
     *
     * ВАЖНОСТЬ ГРАНИЧНЫХ СЛУЧАЕВ:
     * Пустые строки - классический граничный случай (boundary case).
     * Многие баги связаны именно с обработкой пустых значений:
     * - NullPointerException если не проверили на null
     * - Пустые записи в базе данных
     * - Странное отображение в UI
     *
     * ПРИМЕР ИСПОЛЬЗОВАНИЯ:
     * <pre>
     * {@code
     * @Test
     * void shouldAllowNoteWithEmptyDescription() {
     *     NoteCreateRequest request = TestData.noteWithEmptyDescription();
     *     // Если описание необязательно, тест должен пройти
     * }
     * }
     * </pre>
     *
     * @return объект NoteCreateRequest с пустым описанием для тестирования
     */
    public static NoteCreateRequest noteWithEmptyDescription() {
        return new NoteCreateRequest(
                "Note without description",  // Заголовок есть
                "",                          // Пустое описание - проверяем валидацию
                "Personal"                   // Категория есть
        );
    }

    /**
     * Создаёт данные для обновления существующей заметки.
     *
     * ЧТО ВОЗВРАЩАЕТ:
     * Объект NoteUpdateRequest с новыми данными для обновления:
     * - Новый заголовок: "Updated Note Title"
     * - Новое описание: "Updated description content"
     * - Новая категория: "Work"
     * - Статус выполнения: true (заметка помечена как выполненная)
     *
     * ЗАЧЕМ НУЖНО:
     * Для тестирования операции UPDATE (обновления заметки).
     * В типичном тесте:
     * 1. Создаём заметку с simpleNote()
     * 2. Обновляем её данными из updateNoteData()
     * 3. Проверяем, что изменения сохранились
     *
     * РАЗНИЦА МЕЖДУ CREATE И UPDATE:
     * - NoteCreateRequest - для создания НОВОЙ заметки (POST запрос)
     * - NoteUpdateRequest - для обновления СУЩЕСТВУЮЩЕЙ заметки (PUT запрос)
     *
     * Update-запрос обычно содержит все поля, включая те, которые не изменились.
     * Поле "completed" (выполнено) позволяет отмечать заметки как завершённые.
     *
     * ПРИМЕР ИСПОЛЬЗОВАНИЯ:
     * <pre>
     * {@code
     * @Test
     * void shouldUpdateNote() {
     *     // Создаём заметку
     *     NoteCreateRequest createRequest = TestData.simpleNote();
     *     Long noteId = createNote(createRequest);
     *
     *     // Обновляем её
     *     NoteUpdateRequest updateRequest = TestData.updateNoteData();
     *     updateNote(noteId, updateRequest);
     *
     *     // Проверяем, что данные изменились
     *     Note updatedNote = getNote(noteId);
     *     assertEquals("Updated Note Title", updatedNote.getTitle());
     *     assertTrue(updatedNote.isCompleted());
     * }
     * }
     * </pre>
     *
     * @return объект NoteUpdateRequest с новыми данными для обновления заметки
     */
    public static NoteUpdateRequest updateNoteData() {
        return new NoteUpdateRequest(
                "Updated Note Title",        // Новый заголовок
                "Updated description content", // Новое описание
                "Work",                      // Новая категория
                true                         // Помечаем заметку как выполненную
        );
    }

    /*
     * ИТОГИ И ЛУЧШИЕ ПРАКТИКИ:
     * ========================
     *
     * 1. ПЕРЕИСПОЛЬЗОВАНИЕ ТЕСТОВЫХ ДАННЫХ:
     *    Вместо копирования одинаковых данных в каждый тест, создаём их один раз здесь.
     *    Все тесты используют TestData.simpleNote() - это гарантирует консистентность.
     *
     * 2. УПРОЩЕНИЕ ПОДДЕРЖКИ:
     *    Если завтра решим изменить тестовые данные (например, другую категорию),
     *    меняем в ОДНОМ месте, а не в 50 тестах.
     *
     * 3. ЧИТАЕМОСТЬ ТЕСТОВ:
     *    Тест с кодом TestData.simpleNote() понятнее, чем длинный конструктор.
     *    Название метода объясняет, КАКИЕ данные используются.
     *
     * 4. РАЗНЫЕ СЦЕНАРИИ:
     *    У нас есть методы для разных случаев:
     *    - Валидные данные (simpleNote)
     *    - Невалидные данные (noteWithEmptyTitle, noteWithEmptyDescription)
     *    - Данные для обновления (updateNoteData)
     *
     * 5. РАСШИРЯЕМОСТЬ:
     *    Легко добавить новые методы, например:
     *    - noteWithLongTitle() - для тестирования лимитов длины
     *    - noteWithSpecialCharacters() - для тестирования спецсимволов
     *    - noteWithUnicode() - для тестирования юникода (эмодзи, кириллица)
     *
     * КОГДА ДОБАВЛЯТЬ НОВЫЕ МЕТОДЫ:
     * - Если один и тот же набор данных нужен в 2+ тестах - вынесите в TestData
     * - Если тестовые данные сложные - создайте helper-метод
     * - Если тесты становятся нечитаемыми из-за длинных конструкторов - используйте TestData
     */
}
