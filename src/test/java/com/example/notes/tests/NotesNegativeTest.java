package com.example.notes.tests;

import com.example.notes.core.BaseApiTest;
import com.example.notes.data.TestData;
import com.example.notes.endpoints.NotesClient;
import com.example.notes.models.NoteCreateRequest;
import io.restassured.response.Response;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.hamcrest.Matchers.notNullValue;

/**
 * НЕГАТИВНЫЕ ТЕСТЫ для заметок
 *
 * Что такое негативные тесты (Negative Tests)?
 * Это тесты, которые проверяют поведение системы при НЕПРАВИЛЬНЫХ действиях пользователя.
 * В отличие от позитивных тестов (когда всё идёт правильно), негативные тесты проверяют:
 * - Как система реагирует на некорректные данные
 * - Возвращает ли система понятные сообщения об ошибках
 * - Не падает ли сервер при неожиданных ситуациях
 * - Правильные ли HTTP-коды возвращаются при ошибках
 *
 * Цель негативных тестов:
 * - Убедиться, что API корректно обрабатывает ошибки
 * - Проверить, что пользователь получит понятное сообщение об ошибке
 * - Убедиться, что система не "ломается" при некорректных запросах
 * - Проверить правильность HTTP-кодов ответа (400 для плохого запроса, 404 для несуществующего ресурса)
 *
 * Эти тесты очень важны для качества системы, так как пользователи часто делают ошибки:
 * - Забывают заполнить обязательные поля
 * - Вводят неправильные ID
 * - Пытаются удалить то, что уже удалено
 */
@DisplayName("Notes Negative Tests") // Название группы тестов для отчёта
public class NotesNegativeTest extends BaseApiTest { // Наследуемся от базового класса

    /**
     * ТЕСТ: Создание заметки с пустым заголовком должно вернуть ошибку
     *
     * Что проверяет этот тест:
     * - Сервер не позволяет создать заметку без заголовка
     * - Возвращается HTTP-код 400 (Bad Request - плохой запрос)
     * - В ответе есть понятное сообщение об ошибке
     *
     * Код 400 означает, что запрос клиента неправильный (валидация не прошла)
     */
    @Test // JUnit запустит этот метод как тест
    @DisplayName("Create note with empty title should return 400") // Название для отчёта
    public void createNoteWithEmptyTitleShouldFail() {

        // ШАГ 1: Подготавливаем некорректные данные - заметку БЕЗ заголовка
        // TestData.noteWithEmptyTitle() возвращает объект с пустым title
        NoteCreateRequest request = TestData.noteWithEmptyTitle();

        // ШАГ 2: Отправляем POST-запрос на создание заметки с некорректными данными
        // Используем метод createNoteResponse() вместо createNote(),
        // потому что ожидаем ошибку, а не успешный результат
        Response response = NotesClient.createNoteResponse(request);

        // ШАГ 3: ПРОВЕРКИ ответа сервера

        // Проверка 1: Сервер должен вернуть код 400 (Bad Request)
        // 400 = неправильный запрос, данные не прошли валидацию
        response.then()
                .statusCode(400)

                // Проверка 2: В ответе должно быть поле "message" с описанием ошибки
                // notNullValue() - проверяем, что сообщение об ошибке не пустое
                // Пользователь должен понять, что именно не так с его запросом
                .body("message", notNullValue());

        // Если сервер вернул 400 с сообщением - тест пройден!
        // Это значит, что валидация работает правильно
    }

    /**
     * ТЕСТ: Создание заметки с пустым описанием должно вернуть ошибку
     *
     * Что проверяет этот тест:
     * - Сервер не позволяет создать заметку без описания
     * - Возвращается HTTP-код 400 (Bad Request)
     * - В ответе есть сообщение об ошибке
     *
     * Этот тест аналогичен предыдущему, но проверяет валидацию поля description
     */
    @Test // Помечаем как тест
    @DisplayName("Create note with empty description should return 400") // Название для отчёта
    public void createNoteWithEmptyDescriptionShouldFail() {

        // ШАГ 1: Подготавливаем некорректные данные - заметку БЕЗ описания
        NoteCreateRequest request = TestData.noteWithEmptyDescription();

        // ШАГ 2: Отправляем некорректный запрос на сервер
        Response response = NotesClient.createNoteResponse(request);

        // ШАГ 3: ПРОВЕРКИ

        // Проверка 1: Код ответа должен быть 400
        response.then()
                .statusCode(400)

                // Проверка 2: Сообщение об ошибке должно присутствовать
                .body("message", notNullValue());

        // Если валидация описания работает - тест пройден!
    }

    /**
     * ТЕСТ: Получение заметки с невалидным ID должно вернуть 400
     *
     * Что проверяет этот тест:
     * - Сервер корректно обрабатывает запрос заметки с невалидным форматом ID
     * - Возвращается HTTP-код 400 (Bad Request - неправильный запрос)
     * - В ответе есть сообщение об ошибке
     *
     * ОСОБЕННОСТЬ Notes API:
     * API сначала валидирует формат ID (должен быть MongoDB ObjectId).
     * Если формат неправильный - возвращает 400 (Bad Request), а не 404.
     * Код 400 означает, что сам запрос неправильный (невалидный ID).
     */
    @Test // Помечаем как тест
    @DisplayName("Get note with invalid ID should return 400") // Название для отчёта
    public void getNoteWithInvalidIdShouldReturn400() {

        // ШАГ 1: Создаём заведомо невалидный ID заметки
        // Такой формат не соответствует MongoDB ObjectId
        String invalidId = "invalid-note-id-12345";

        // ШАГ 2: Пытаемся получить заметку с невалидным ID
        Response response = NotesClient.getNoteResponse(invalidId);

        // ШАГ 3: ПРОВЕРКИ

        // Проверка 1: Сервер должен вернуть код 400 (Bad Request)
        // 400 = невалидный формат ID
        response.then()
                .statusCode(400)

                // Проверка 2: Должно быть сообщение об ошибке
                // Пользователь должен понять, что ID невалидный
                .body("message", notNullValue());

        // Если сервер правильно валидирует формат ID - тест пройден!
    }

    /**
     * ТЕСТ: Удаление заметки с невалидным ID должно вернуть 400
     *
     * Что проверяет этот тест:
     * - Попытка удалить заметку с невалидным форматом ID не приводит к краху сервера
     * - Возвращается HTTP-код 400 (Bad Request)
     * - В ответе есть сообщение об ошибке
     *
     * ОСОБЕННОСТЬ Notes API:
     * API сначала валидирует формат ID (должен быть MongoDB ObjectId).
     * Если формат неправильный - возвращает 400 (Bad Request), а не 404.
     */
    @Test // Помечаем как тест
    @DisplayName("Delete note with invalid ID should return 400") // Название для отчёта
    public void deleteNoteWithInvalidIdShouldReturn400() {

        // ШАГ 1: Создаём заведомо невалидный ID заметки
        String invalidId = "non-existent-note-id-99999";

        // ШАГ 2: Пытаемся удалить заметку с невалидным ID
        Response response = NotesClient.deleteNoteResponse(invalidId);

        // ШАГ 3: ПРОВЕРКИ

        // Проверка 1: Должен вернуться код 400 (Bad Request)
        response.then()
                .statusCode(400)

                // Проверка 2: Должно быть сообщение об ошибке
                .body("message", notNullValue());

        // Если сервер корректно валидирует формат ID при удалении - тест пройден!
    }

    /**
     * ТЕСТ: Обновление заметки с невалидным ID должно вернуть 400
     *
     * Что проверяет этот тест:
     * - Попытка обновить заметку с невалидным форматом ID не приводит к ошибкам сервера
     * - Возвращается HTTP-код 400 (Bad Request)
     * - В ответе есть сообщение об ошибке
     *
     * ОСОБЕННОСТЬ Notes API:
     * API сначала валидирует формат ID (должен быть MongoDB ObjectId).
     * Если формат неправильный - возвращает 400 (Bad Request), а не 404.
     */
    @Test // Помечаем как тест
    @DisplayName("Update note with invalid ID should return 400") // Название для отчёта
    public void updateNoteWithInvalidIdShouldReturn400() {

        // ШАГ 1: Создаём заведомо невалидный ID заметки
        String invalidId = "non-existent-note-id-88888";

        // ШАГ 2: Пытаемся обновить заметку с невалидным ID
        // Передаём невалидный ID и корректные данные для обновления
        Response response = NotesClient.updateNoteResponse(invalidId, TestData.updateNoteData());

        // ШАГ 3: ПРОВЕРКИ

        // Проверка 1: Должен вернуться код 400 (Bad Request)
        // Невалидный формат ID
        response.then()
                .statusCode(400)

                // Проверка 2: Должно быть сообщение об ошибке
                .body("message", notNullValue());

        // Если сервер корректно валидирует формат ID при обновлении - тест пройден!
    }

    /*
     * ИТОГО: Все негативные тесты проверяют, что система:
     * 1. Не падает при неправильных действиях пользователя
     * 2. Возвращает правильные HTTP-коды ошибок (400 для неправильных данных, 404 для несуществующих ресурсов)
     * 3. Предоставляет понятные сообщения об ошибках
     *
     * Это обеспечивает хороший пользовательский опыт (UX) - пользователь всегда понимает,
     * что пошло не так, и может исправить свою ошибку.
     */
}
